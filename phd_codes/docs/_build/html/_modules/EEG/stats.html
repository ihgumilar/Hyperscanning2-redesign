<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EEG.stats &mdash; Hyperscanning Experiments 1.0.0 Exp2-redesign documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Hyperscanning Experiments
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">phd_codes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Hyperscanning Experiments</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">EEG.stats</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for EEG.stats</h1><div class="highlight"><pre>
<span></span><span class="c1"># ### Relevant packages</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="kn">import</span> <span class="nn">heartrate</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">snoop</span>
<span class="kn">from</span> <span class="nn">EEG.label_converter</span> <span class="kn">import</span> <span class="n">get_electrode_labels_connections</span>
<span class="kn">from</span> <span class="nn">hypyp</span> <span class="kn">import</span> <span class="n">analyses</span><span class="p">,</span> <span class="n">prep</span><span class="p">,</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">read_pickle</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>


<span class="c1"># %%</span>
<div class="viewcode-block" id="Connections"><a class="viewcode-back" href="../../EEG.html#EEG.stats.Connections">[docs]</a><span class="k">class</span> <span class="nc">Connections</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that is related to a number of significant connections of EEG data</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Connections.permut_sig_connection"><a class="viewcode-back" href="../../EEG.html#EEG.stats.Connections.permut_sig_connection">[docs]</a>    <span class="k">def</span> <span class="nf">permut_sig_connection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">preproc_files</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">sig_connection_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n_permutations</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective : - Out of 256 connections of each pair (16 x 16 electrodes), this function will try to find out</span>
<span class="sd">                    which connections that are statistically significant. This will run permutation.</span>

<span class="sd">                    REMEMBER !! : - The higher permutation, the longer it takes time to process</span>
<span class="sd">                                    - The permutation is performed for inter-brain synchrony scores</span>
<span class="sd">                                    that are computed with three different algorithms:</span>
<span class="sd">                                        1. ccorr</span>
<span class="sd">                                        2. coh</span>
<span class="sd">                                        3. plv</span>

<span class="sd">        Parameters :</span>
<span class="sd">                    - preproc_files(str) : Path to where pre-processed files are stored.</span>
<span class="sd">                                        (REMEMBER ! Different eye condition (pre/pro) requires a unique directory)</span>

<span class="sd">                    - sig_connection_path(str) : Path to where significant connections files will be stored</span>
<span class="sd">                                                 (REMEMBER ! Different eye condition (pre/pro) requires a unique directory)</span>
<span class="sd">                                                Note :</span>
<span class="sd">                                                    There will be 3 main containers (actual score of ccor, plv, coh).</span>
<span class="sd">                                                    Each of them has 4 lists (theta, alpha, beta, and gamma)</span>

<span class="sd">        Output     :</span>
<span class="sd">                    - *.pkl files, each pair will have 6 files as listed below :</span>

<span class="sd">                    1. Pre_ccorr_combined_pair_S1_and_S2_actual_score_data.pkl</span>
<span class="sd">                    2. Pre_ccorr_combined_pair_S1_and_S2_connection_data.pkl</span>
<span class="sd">                    3. Pre_coh_combined_pair_S1_and_S2_actual_score_data.pkl</span>
<span class="sd">                    4. Pre_coh_combined_pair_S1_and_S2_actual_score_data.pkl</span>
<span class="sd">                    5. Pre_plv_combined_pair_S1_and_S2_actual_score_data.pkl</span>
<span class="sd">                    6. Pre_plv_combined_pair_S1_and_S2_connection_data.pkl</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">heartrate</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">browser</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">path_2_preproc_averted_pre</span> <span class="o">=</span> <span class="n">preproc_files</span>

        <span class="n">saved_directory</span> <span class="o">=</span> <span class="n">sig_connection_path</span>

        <span class="c1"># IMPORTANT ! how many permutations you want</span>
        <span class="n">n_perms</span> <span class="o">=</span> <span class="n">n_permutations</span>

        <span class="c1"># List files that are contained in a specified directory</span>
        <span class="n">list_of_files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_2_preproc_averted_pre</span><span class="p">)</span>

        <span class="c1"># Change working directory</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">path_2_preproc_averted_pre</span><span class="p">)</span>

        <span class="c1"># To loop subject number.</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_files</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="n">freq_bands</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Theta&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
            <span class="s2">&quot;Alpha&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">7.5</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span>
            <span class="s2">&quot;Beta&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">13.5</span><span class="p">,</span> <span class="mf">29.5</span><span class="p">],</span>
            <span class="s2">&quot;Gamma&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span>
        <span class="p">}</span>
        <span class="n">freq_bands</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">freq_bands</span><span class="p">)</span>

        <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;FP1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Fp2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;F7&quot;</span><span class="p">,</span>
            <span class="s2">&quot;F3&quot;</span><span class="p">,</span>
            <span class="s2">&quot;F4&quot;</span><span class="p">,</span>
            <span class="s2">&quot;F8&quot;</span><span class="p">,</span>
            <span class="s2">&quot;T7&quot;</span><span class="p">,</span>
            <span class="s2">&quot;C3&quot;</span><span class="p">,</span>
            <span class="s2">&quot;C4&quot;</span><span class="p">,</span>
            <span class="s2">&quot;T8&quot;</span><span class="p">,</span>
            <span class="s2">&quot;P7&quot;</span><span class="p">,</span>
            <span class="s2">&quot;P3&quot;</span><span class="p">,</span>
            <span class="s2">&quot;P4&quot;</span><span class="p">,</span>
            <span class="s2">&quot;P8&quot;</span><span class="p">,</span>
            <span class="s2">&quot;O1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;O2&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">ch_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;eeg&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">16</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">create_info</span><span class="p">(</span><span class="n">ch_names</span><span class="o">=</span><span class="n">ch_names</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="mi">125</span><span class="p">,</span> <span class="n">ch_types</span><span class="o">=</span><span class="n">ch_types</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">snoop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">),</span>
                <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Please, listen 2 music &amp; have some coffee...&quot;</span><span class="p">,</span>
            <span class="p">):</span>

                <span class="n">filename1</span> <span class="o">=</span> <span class="n">list_of_files</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">filename2</span> <span class="o">=</span> <span class="n">list_of_files</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Load preprocessed epochs</span>
                <span class="n">load_epoch_S1</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_epochs</span><span class="p">(</span><span class="n">filename1</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">load_epoch_S2</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_epochs</span><span class="p">(</span><span class="n">filename2</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Equalize number of epochs</span>
                <span class="n">mne</span><span class="o">.</span><span class="n">epochs</span><span class="o">.</span><span class="n">equalize_epoch_counts</span><span class="p">([</span><span class="n">load_epoch_S1</span><span class="p">,</span> <span class="n">load_epoch_S2</span><span class="p">])</span>

                <span class="n">sampling_rate</span> <span class="o">=</span> <span class="n">load_epoch_S1</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;sfreq&quot;</span><span class="p">]</span>

                <span class="c1"># Analysing data Welch Power Spectral Density. Here for ex, the frequency-band-of-interest,</span>
                <span class="c1"># frequencies for which power spectral density is actually computed are returned in freq_list,and PSD values are averaged across epochs</span>
                <span class="c1"># Frequencies = Theta - Gamma (fmin, fmax) - kindly see the freq_bands</span>

                <span class="n">psd1</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span>
                    <span class="n">load_epoch_S1</span><span class="p">,</span>
                    <span class="n">fmin</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">fmax</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                    <span class="n">n_fft</span><span class="o">=</span><span class="mi">125</span><span class="p">,</span>
                    <span class="n">n_per_seg</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
                    <span class="n">epochs_average</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">psd2</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span>
                    <span class="n">load_epoch_S2</span><span class="p">,</span>
                    <span class="n">fmin</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">fmax</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                    <span class="n">n_fft</span><span class="o">=</span><span class="mi">125</span><span class="p">,</span>
                    <span class="n">n_per_seg</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
                    <span class="n">epochs_average</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">data_psd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">psd1</span><span class="o">.</span><span class="n">psd</span><span class="p">,</span> <span class="n">psd2</span><span class="o">.</span><span class="n">psd</span><span class="p">])</span>

                <span class="c1"># ### Connectivity</span>
                <span class="c1"># with ICA</span>
                <span class="n">data_inter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">load_epoch_S1</span><span class="p">,</span> <span class="n">load_epoch_S2</span><span class="p">])</span>
                <span class="n">result_intra</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Computing analytic signal per frequency band</span>
                <span class="c1"># With ICA (Compute complex signal, that will be used as input for calculating connectivity, eg. power-correlation score)</span>
                <span class="n">complex_signal</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">compute_freq_bands</span><span class="p">(</span>
                    <span class="n">data_inter</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">freq_bands</span>
                <span class="p">)</span>

                <span class="c1"># Computing frequency- and time-frequency-domain connectivity, &#39;ccorr&#39;, &#39;plv&#39; and &#39;coh&#39;</span>
                <span class="n">ground_result_ccorr</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">compute_sync</span><span class="p">(</span>
                    <span class="n">complex_signal</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;ccorr&quot;</span>
                <span class="p">)</span>
                <span class="n">ground_result_plv</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">compute_sync</span><span class="p">(</span><span class="n">complex_signal</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;plv&quot;</span><span class="p">)</span>
                <span class="n">ground_result_coh</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">compute_sync</span><span class="p">(</span><span class="n">complex_signal</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;coh&quot;</span><span class="p">)</span>

                <span class="c1"># Slicing results to get the Inter-brain part of the matrix.</span>
                <span class="c1"># Refer to this for slicing or counting no. of connections later on</span>
                <span class="n">n_ch</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">load_epoch_S1</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;ch_names&quot;</span><span class="p">])</span>
                <span class="n">theta_ccorr</span><span class="p">,</span> <span class="n">alpha_ccorr</span><span class="p">,</span> <span class="n">beta_ccorr</span><span class="p">,</span> <span class="n">gamma_ccorr</span> <span class="o">=</span> <span class="n">ground_result_ccorr</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_ch</span><span class="p">,</span> <span class="n">n_ch</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_ch</span>
                <span class="p">]</span>
                <span class="n">theta_plv</span><span class="p">,</span> <span class="n">alpha_plv</span><span class="p">,</span> <span class="n">beta_plv</span><span class="p">,</span> <span class="n">gamma_plv</span> <span class="o">=</span> <span class="n">ground_result_plv</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_ch</span><span class="p">,</span> <span class="n">n_ch</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_ch</span>
                <span class="p">]</span>
                <span class="n">theta_coh</span><span class="p">,</span> <span class="n">alpha_coh</span><span class="p">,</span> <span class="n">beta_coh</span><span class="p">,</span> <span class="n">gamma_coh</span> <span class="o">=</span> <span class="n">ground_result_coh</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_ch</span><span class="p">,</span> <span class="n">n_ch</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_ch</span>
                <span class="p">]</span>

                <span class="c1"># Get the type of data this and change the type to ndarray in later down the section</span>
                <span class="c1"># So that it can be the same type of data ndarray of ground truth and ndarray of significant connection</span>
                <span class="c1"># ground truth matrix using ccorr</span>
                <span class="n">ccorr_combined_ground_truth_matrices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">theta_ccorr</span><span class="p">,</span>
                    <span class="n">alpha_ccorr</span><span class="p">,</span>
                    <span class="n">beta_ccorr</span><span class="p">,</span>
                    <span class="n">gamma_ccorr</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="c1"># ground truth matrix using plv</span>
                <span class="n">plv_combined_ground_truth_matrices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">theta_plv</span><span class="p">,</span>
                    <span class="n">alpha_plv</span><span class="p">,</span>
                    <span class="n">beta_plv</span><span class="p">,</span>
                    <span class="n">gamma_plv</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="c1"># ground truth matrix using coh</span>
                <span class="n">coh_combined_ground_truth_matrices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">theta_coh</span><span class="p">,</span>
                    <span class="n">alpha_coh</span><span class="p">,</span>
                    <span class="n">beta_coh</span><span class="p">,</span>
                    <span class="n">gamma_coh</span><span class="p">,</span>
                <span class="p">]</span>

                <span class="c1"># array that stores 1 or 0 depending on whether the connection between two electrodes are significant (for ccorr)</span>
                <span class="n">ccorr_theta_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">ccorr_alpha_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">ccorr_beta_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">ccorr_gamma_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">ccorr_combined_freq_n_connections</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">ccorr_theta_n_connections</span><span class="p">,</span>
                    <span class="n">ccorr_alpha_n_connections</span><span class="p">,</span>
                    <span class="n">ccorr_beta_n_connections</span><span class="p">,</span>
                    <span class="n">ccorr_gamma_n_connections</span><span class="p">,</span>
                <span class="p">]</span>

                <span class="c1"># array that stores 1 or 0 depending on whether the connection between two electrodes are significant (for plv)</span>
                <span class="n">plv_theta_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">plv_alpha_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">plv_beta_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">plv_gamma_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">plv_combined_freq_n_connections</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">plv_theta_n_connections</span><span class="p">,</span>
                    <span class="n">plv_alpha_n_connections</span><span class="p">,</span>
                    <span class="n">plv_beta_n_connections</span><span class="p">,</span>
                    <span class="n">plv_gamma_n_connections</span><span class="p">,</span>
                <span class="p">]</span>

                <span class="c1"># array that stores 1 or 0 depending on whether the connection between two electrodes are significant (for coh)</span>
                <span class="n">coh_theta_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">coh_alpha_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">coh_beta_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">coh_gamma_n_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
                <span class="n">coh_combined_freq_n_connections</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">coh_theta_n_connections</span><span class="p">,</span>
                    <span class="n">coh_alpha_n_connections</span><span class="p">,</span>
                    <span class="n">coh_beta_n_connections</span><span class="p">,</span>
                    <span class="n">coh_gamma_n_connections</span><span class="p">,</span>
                <span class="p">]</span>

                <span class="c1">############ Implemanting Permutation test ################################</span>

                <span class="c1"># Define lists that contain significant actual scores (ccor, plv, coh) along with electrode pair labels</span>

                <span class="n">ccorr_combined_freqs_electrode_pair_n_actual_score</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">plv_combined_freqs_electrode_pair_n_actual_score</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">coh_combined_freqs_electrode_pair_n_actual_score</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">electrode_pair_n_actual_score_theta_ccorr</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">electrode_pair_n_actual_score_alpha_ccorr</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">electrode_pair_n_actual_score_beta_ccorr</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">electrode_pair_n_actual_score_gamma_ccorr</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">electrode_pair_n_actual_score_theta_plv</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">electrode_pair_n_actual_score_alpha_plv</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">electrode_pair_n_actual_score_beta_plv</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">electrode_pair_n_actual_score_gamma_plv</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">electrode_pair_n_actual_score_theta_coh</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">electrode_pair_n_actual_score_alpha_coh</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">electrode_pair_n_actual_score_beta_coh</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">electrode_pair_n_actual_score_gamma_coh</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">participant1_channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">participant2_channel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)):</span>

                        <span class="c1"># epoch1 should just be a specific electrode e.g. FP1.</span>
                        <span class="c1"># epoch1 = load_epoch_S1.pick_channels(&#39;FP1&#39;) or something. &lt;- note this is not correct, it&#39;s just an idea</span>
                        <span class="n">epoch1</span> <span class="o">=</span> <span class="n">load_epoch_S1</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span>
                            <span class="n">picks</span><span class="o">=</span><span class="n">ch_names</span><span class="p">[</span><span class="n">participant1_channel</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">epoch2</span> <span class="o">=</span> <span class="n">load_epoch_S2</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span>
                            <span class="n">picks</span><span class="o">=</span><span class="n">ch_names</span><span class="p">[</span><span class="n">participant2_channel</span><span class="p">]</span>
                        <span class="p">)</span>

                        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c1"># set a random seed</span>

                        <span class="c1"># Permute for several times as defined above</span>
                        <span class="n">n_perms</span> <span class="o">=</span> <span class="n">n_permutations</span>

                        <span class="n">k_ccorr_theta_permuted</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="p">[]</span>
                        <span class="p">)</span>  <span class="c1"># initialising list that will store all the ccor values (ccorr value range of 0 to +1). its length should equal n_perms</span>
                        <span class="n">k_ccorr_alpha_permuted</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">k_ccorr_beta_permuted</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">k_ccorr_gamma_permuted</span> <span class="o">=</span> <span class="p">[]</span>

                        <span class="n">k_plv_theta_permuted</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="p">[]</span>
                        <span class="p">)</span>  <span class="c1"># initialising list that will store all the plv values (plv value range of 0 to +1). its length should equal n_perms</span>
                        <span class="n">k_plv_alpha_permuted</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">k_plv_beta_permuted</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">k_plv_gamma_permuted</span> <span class="o">=</span> <span class="p">[]</span>

                        <span class="n">k_coh_theta_permuted</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="p">[]</span>
                        <span class="p">)</span>  <span class="c1"># initialising list that will store all the coh values (coh value range of 0 to +1). its length should equal n_perms</span>
                        <span class="n">k_coh_alpha_permuted</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">k_coh_beta_permuted</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">k_coh_gamma_permuted</span> <span class="o">=</span> <span class="p">[]</span>

                        <span class="c1"># for each iterations, undergo permutation and calculate ccorr or plv or coh</span>
                        <span class="k">for</span> <span class="n">iperm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perms</span><span class="p">):</span>

                            <span class="c1"># for participant 1</span>
                            <span class="n">perm1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">epoch1</span><span class="p">)</span>
                            <span class="p">)</span>  <span class="c1"># randomising indices without replacement</span>
                            <span class="n">epoch1_in_permuted_order</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">epoch1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm1</span>
                            <span class="p">]</span>  <span class="c1"># index the epoch to get permuted epochs</span>

                            <span class="c1"># for participant 2</span>
                            <span class="n">epoch2_in_permuted_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">epoch2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm1</span><span class="p">]</span>

                            <span class="c1"># combine the two permuted epochs together</span>
                            <span class="c1"># data_inter_permuted = np.array([epoch1, epoch2])</span>
                            <span class="n">data_inter_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">epoch1_in_permuted_order</span><span class="p">,</span> <span class="n">epoch2_in_permuted_order</span><span class="p">]</span>
                            <span class="p">)</span>

                            <span class="c1"># Calculate ccorr or plv or coh of two permuted data. We only need to calculate complex_signal once for all &#39;ccorr&#39;, &#39;plv&#39; and &#39;coh&#39; because these all use same complex_signal</span>
                            <span class="n">complex_signal</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">compute_freq_bands</span><span class="p">(</span>
                                <span class="n">data_inter_permuted</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="n">freq_bands</span>
                            <span class="p">)</span>

                            <span class="c1"># Computing frequency- and time-frequency-domain connectivity, &#39;ccorr&#39;, &#39;plv&#39;, &#39;coh&#39;.</span>
                            <span class="c1"># add analyses.compute_sync(...) if you would like to test more connectivity analysis method e.g. &#39;pdc&#39;, etc.</span>
                            <span class="n">result_ccorr</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">compute_sync</span><span class="p">(</span>
                                <span class="n">complex_signal</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;ccorr&quot;</span>
                            <span class="p">)</span>
                            <span class="n">result_plv</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">compute_sync</span><span class="p">(</span>
                                <span class="n">complex_signal</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;plv&quot;</span>
                            <span class="p">)</span>
                            <span class="n">result_coh</span> <span class="o">=</span> <span class="n">analyses</span><span class="o">.</span><span class="n">compute_sync</span><span class="p">(</span>
                                <span class="n">complex_signal</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;coh&quot;</span>
                            <span class="p">)</span>

                            <span class="c1"># comparing 1 channel of participant 1 against 1 channel of participant 2</span>
                            <span class="c1"># n_ch is 1 instead of 16 because we are finding connection of 1 electrode and 1 other electrode each time.</span>
                            <span class="n">n_ch</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="c1"># slice the result array to seperate into different frequencies. do this for &#39;ccorr&#39;, &#39;plv&#39; and &#39;coh&#39;</span>
                            <span class="p">(</span>
                                <span class="n">ccorr_theta_permuted</span><span class="p">,</span>
                                <span class="n">ccorr_alpha_permuted</span><span class="p">,</span>
                                <span class="n">ccorr_beta_permuted</span><span class="p">,</span>
                                <span class="n">ccorr_gamma_permuted</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">=</span> <span class="n">result_ccorr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_ch</span><span class="p">,</span> <span class="n">n_ch</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_ch</span><span class="p">]</span>
                            <span class="p">(</span>
                                <span class="n">plv_theta_permuted</span><span class="p">,</span>
                                <span class="n">plv_alpha_permuted</span><span class="p">,</span>
                                <span class="n">plv_beta_permuted</span><span class="p">,</span>
                                <span class="n">plv_gamma_permuted</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">=</span> <span class="n">result_plv</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_ch</span><span class="p">,</span> <span class="n">n_ch</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_ch</span><span class="p">]</span>
                            <span class="p">(</span>
                                <span class="n">coh_theta_permuted</span><span class="p">,</span>
                                <span class="n">coh_alpha_permuted</span><span class="p">,</span>
                                <span class="n">coh_beta_permuted</span><span class="p">,</span>
                                <span class="n">coh_gamma_permuted</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">=</span> <span class="n">result_coh</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_ch</span><span class="p">,</span> <span class="n">n_ch</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_ch</span><span class="p">]</span>

                            <span class="c1"># append the ccorr value to the corresponding list</span>
                            <span class="n">k_ccorr_theta_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccorr_theta_permuted</span><span class="p">)</span>
                            <span class="n">k_ccorr_alpha_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccorr_alpha_permuted</span><span class="p">)</span>
                            <span class="n">k_ccorr_beta_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccorr_beta_permuted</span><span class="p">)</span>
                            <span class="n">k_ccorr_gamma_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ccorr_gamma_permuted</span><span class="p">)</span>
                            <span class="c1"># list of 4 lists stored. 1st index stores theta ccorr permutation scores, 2nd index stores alpha ccorr permutation scores, etc.</span>
                            <span class="n">combined_k_ccorr_frequency_permuted</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">k_ccorr_theta_permuted</span><span class="p">,</span>
                                <span class="n">k_ccorr_alpha_permuted</span><span class="p">,</span>
                                <span class="n">k_ccorr_beta_permuted</span><span class="p">,</span>
                                <span class="n">k_ccorr_gamma_permuted</span><span class="p">,</span>
                            <span class="p">]</span>

                            <span class="c1"># append the plv value to the corresponding list</span>
                            <span class="n">k_plv_theta_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plv_theta_permuted</span><span class="p">)</span>
                            <span class="n">k_plv_alpha_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plv_alpha_permuted</span><span class="p">)</span>
                            <span class="n">k_plv_beta_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plv_beta_permuted</span><span class="p">)</span>
                            <span class="n">k_plv_gamma_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plv_gamma_permuted</span><span class="p">)</span>
                            <span class="c1"># list of 4 lists stored. 1st index stores theta plv permutation scores, 2nd index stores alpha plv permutation scores, etc.</span>
                            <span class="n">combined_k_plv_frequency_permuted</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">k_plv_theta_permuted</span><span class="p">,</span>
                                <span class="n">k_plv_alpha_permuted</span><span class="p">,</span>
                                <span class="n">k_plv_beta_permuted</span><span class="p">,</span>
                                <span class="n">k_plv_gamma_permuted</span><span class="p">,</span>
                            <span class="p">]</span>

                            <span class="c1"># append the coh value to the corresponding list</span>
                            <span class="n">k_coh_theta_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coh_theta_permuted</span><span class="p">)</span>
                            <span class="n">k_coh_alpha_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coh_alpha_permuted</span><span class="p">)</span>
                            <span class="n">k_coh_beta_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coh_beta_permuted</span><span class="p">)</span>
                            <span class="n">k_coh_gamma_permuted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coh_gamma_permuted</span><span class="p">)</span>
                            <span class="c1"># list of 4 lists stored. 1st index stores theta coh permutation scores, 2nd index stores alpha coh permutation scores, etc.</span>
                            <span class="n">combined_k_coh_frequency_permuted</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="n">k_coh_theta_permuted</span><span class="p">,</span>
                                <span class="n">k_coh_alpha_permuted</span><span class="p">,</span>
                                <span class="n">k_coh_beta_permuted</span><span class="p">,</span>
                                <span class="n">k_coh_gamma_permuted</span><span class="p">,</span>
                            <span class="p">]</span>

                        <span class="c1"># iterate each theta, alpha, beta, gamma</span>
                        <span class="k">for</span> <span class="n">iterate_each_freq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">combined_k_ccorr_frequency_permuted</span><span class="p">)</span>
                        <span class="p">):</span>  <span class="c1"># 4 because we have classified frequency range into 4 types: theta, alpha, beta, gamma</span>

                            <span class="c1"># Calculate p value</span>
                            <span class="n">z_value</span> <span class="o">=</span> <span class="mf">1.96</span>  <span class="c1"># equivalent to p value of 0.05</span>

                            <span class="c1"># calculate mean and standard deviation for each frequency band using ccorr</span>
                            <span class="n">ccorr_mean_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                                <span class="n">combined_k_ccorr_frequency_permuted</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">ccorr_std_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span>
                                <span class="n">combined_k_ccorr_frequency_permuted</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">ccorr_z_score</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">ccorr_combined_ground_truth_matrices</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">][</span>
                                    <span class="n">participant1_channel</span>
                                <span class="p">][</span><span class="n">participant2_channel</span><span class="p">]</span>
                                <span class="o">-</span> <span class="n">ccorr_mean_permuted</span>
                            <span class="p">)</span> <span class="o">/</span> <span class="n">ccorr_std_permuted</span>
                            <span class="c1"># checking if the z score is greater than z value (p &lt; .05) i.e. if the connection is significant or not. this serves as a marker of significant connection between two electrodes</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ccorr_z_score</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">z_value</span><span class="p">:</span>
                                <span class="c1"># assign value 1 if the connection between ch_names[participant1_channel] and  ch_names[participant2_channel] is significant, otherwise 0 by default</span>
                                <span class="c1"># this is a 4 x 16 x 16 array. 1st index identifies which frequency band it is (e.g. theta, alpha, beta, gamma), and 2nd index represent the electrode of first participant, and 3rd index represent the electrode of second participant</span>
                                <span class="n">ccorr_combined_freq_n_connections</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">][</span>
                                    <span class="n">participant1_channel</span>
                                <span class="p">][</span><span class="n">participant2_channel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                            <span class="c1"># calculate mean and standard deviation for each frequency band using plv</span>
                            <span class="n">plv_mean_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                                <span class="n">combined_k_plv_frequency_permuted</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">plv_std_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span>
                                <span class="n">combined_k_plv_frequency_permuted</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">plv_z_score</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">plv_combined_ground_truth_matrices</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">][</span>
                                    <span class="n">participant1_channel</span>
                                <span class="p">][</span><span class="n">participant2_channel</span><span class="p">]</span>
                                <span class="o">-</span> <span class="n">plv_mean_permuted</span>
                            <span class="p">)</span> <span class="o">/</span> <span class="n">plv_std_permuted</span>
                            <span class="c1"># checking if the z score is greater than z value (p &lt; .05) i.e. if the connection is significant or not. this serves as a marker of significant connection between two electrodes</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">plv_z_score</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">z_value</span><span class="p">:</span>
                                <span class="c1"># assign value 1 if the connection between ch_names[participant1_channel] and  ch_names[participant2_channel] is significant, otherwise 0 by default</span>
                                <span class="c1"># this is a 4 x 16 x 16 array. 1st index identifies which frequency band it is (e.g. theta, alpha, beta, gamma), and 2nd index represent the electrode of first participant, and 3rd index represent the electrode of second participant</span>
                                <span class="n">plv_combined_freq_n_connections</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">][</span>
                                    <span class="n">participant1_channel</span>
                                <span class="p">][</span><span class="n">participant2_channel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                            <span class="c1"># calculate mean and standard deviation for each frequency band using coh</span>
                            <span class="n">coh_mean_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                                <span class="n">combined_k_coh_frequency_permuted</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">coh_std_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span>
                                <span class="n">combined_k_coh_frequency_permuted</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="n">coh_z_score</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">coh_combined_ground_truth_matrices</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">][</span>
                                    <span class="n">participant1_channel</span>
                                <span class="p">][</span><span class="n">participant2_channel</span><span class="p">]</span>
                                <span class="o">-</span> <span class="n">coh_mean_permuted</span>
                            <span class="p">)</span> <span class="o">/</span> <span class="n">coh_std_permuted</span>
                            <span class="c1"># checking if the z score is greater than z value (p &lt; .05) i.e. if the connection is significant or not. this serves as a marker of significant connection between two electrodes</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coh_z_score</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">z_value</span><span class="p">:</span>
                                <span class="c1"># assign value 1 if the connection between ch_names[participant1_channel] and  ch_names[participant2_channel] is significant, otherwise 0 by default</span>
                                <span class="c1"># this is a 4 x 16 x 16 array. 1st index identifies which frequency band it is (e.g. theta, alpha, beta, gamma), and 2nd index represent the electrode of first participant, and 3rd index represent the electrode of second participant</span>
                                <span class="n">coh_combined_freq_n_connections</span><span class="p">[</span><span class="n">iterate_each_freq</span><span class="p">][</span>
                                    <span class="n">participant1_channel</span>
                                <span class="p">][</span><span class="n">participant2_channel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># convert the 4 x 16 x 16 array into a list (marker significant connection matrix)</span>
                <span class="n">ccorr_combined_freq_n_connections_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">ccorr_combined_freq_n_connections</span>
                <span class="p">)</span>
                <span class="n">plv_combined_freq_n_connections_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">plv_combined_freq_n_connections</span>
                <span class="p">)</span>
                <span class="n">coh_combined_freq_n_connections_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">coh_combined_freq_n_connections</span>
                <span class="p">)</span>

                <span class="c1"># Progress getting actual score from marker significant connection matrix (ccorr)</span>
                <span class="c1"># Iterate over frequency (there are 4 , ie. theta, alpha, beta, gamma)</span>
                <span class="n">theta_sig_electrode_pair_ccorr</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">alpha_sig_electrode_pair_ccorr</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">beta_sig_electrode_pair_ccorr</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">gamma_sig_electrode_pair_ccorr</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">idx_freq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ccorr_combined_freq_n_connections</span><span class="p">)):</span>
                    <span class="c1"># Iterate over row of matrix (16 x 16)</span>
                    <span class="k">for</span> <span class="n">idx_row</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="n">ccorr_combined_freq_n_connections</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="c1"># Iterate over column of matrix (16 x 16)</span>
                        <span class="k">for</span> <span class="n">idx_col</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                            <span class="n">ccorr_combined_freq_n_connections</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">][</span><span class="n">idx_row</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="n">ccorr_combined_freq_n_connections</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">][</span><span class="n">idx_row</span><span class="p">][</span>
                                    <span class="n">idx_col</span>
                                <span class="p">]</span>
                                <span class="o">==</span> <span class="mi">1</span>
                            <span class="p">):</span>
                                <span class="n">idx_sig_connection</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">idx_row</span><span class="p">,</span> <span class="n">idx_col</span><span class="p">])</span>
                                <span class="c1"># Get actual score</span>
                                <span class="n">actual_score</span> <span class="o">=</span> <span class="n">ccorr_combined_ground_truth_matrices</span><span class="p">[</span>
                                    <span class="n">idx_freq</span>
                                <span class="p">][</span><span class="n">idx_row</span><span class="p">][</span><span class="n">idx_col</span><span class="p">]</span>
                                <span class="c1"># Get pair label of electorode</span>
                                <span class="n">sig_electrode_pair_label</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">get_electrode_labels_connections</span><span class="p">(</span><span class="n">idx_sig_connection</span><span class="p">)</span>
                                <span class="p">)</span>

                                <span class="n">electrode_pair_n_actual_score_ccorr</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="n">sig_electrode_pair_label</span><span class="p">:</span> <span class="n">actual_score</span>
                                <span class="p">}</span>

                                <span class="c1"># Put that string into a unique list (theta, alpha, beta, or gamma list for ccorr)</span>
                                <span class="k">if</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">theta_sig_electrode_pair_ccorr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_ccorr</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">alpha_sig_electrode_pair_ccorr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_ccorr</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                    <span class="n">beta_sig_electrode_pair_ccorr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_ccorr</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                    <span class="n">gamma_sig_electrode_pair_ccorr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_ccorr</span>
                                    <span class="p">)</span>

                <span class="c1"># Create main list that contains all the above 4 lists of frequency.</span>
                <span class="n">ccorr_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">theta_sig_electrode_pair_ccorr</span>
                <span class="p">)</span>
                <span class="n">ccorr_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">alpha_sig_electrode_pair_ccorr</span>
                <span class="p">)</span>
                <span class="n">ccorr_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">beta_sig_electrode_pair_ccorr</span>
                <span class="p">)</span>
                <span class="n">ccorr_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">gamma_sig_electrode_pair_ccorr</span>
                <span class="p">)</span>

                <span class="c1"># Progress getting actual score from marker significant connection matrix (plv)</span>
                <span class="c1"># Iterate over frequency (there are 4 , ie. theta, alpha, beta, gamma)</span>
                <span class="n">theta_sig_electrode_pair_plv</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">alpha_sig_electrode_pair_plv</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">beta_sig_electrode_pair_plv</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">gamma_sig_electrode_pair_plv</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">idx_freq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plv_combined_freq_n_connections</span><span class="p">)):</span>
                    <span class="c1"># Iterate over row of matrix (16 x 16)</span>
                    <span class="k">for</span> <span class="n">idx_row</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="n">plv_combined_freq_n_connections</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="c1"># Iterate over column of matrix (16 x 16)</span>
                        <span class="k">for</span> <span class="n">idx_col</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                            <span class="n">plv_combined_freq_n_connections</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">][</span><span class="n">idx_row</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="n">plv_combined_freq_n_connections</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">][</span><span class="n">idx_row</span><span class="p">][</span>
                                    <span class="n">idx_col</span>
                                <span class="p">]</span>
                                <span class="o">==</span> <span class="mi">1</span>
                            <span class="p">):</span>
                                <span class="n">idx_sig_connection</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">idx_row</span><span class="p">,</span> <span class="n">idx_col</span><span class="p">])</span>
                                <span class="c1"># Get actual score</span>
                                <span class="n">actual_score</span> <span class="o">=</span> <span class="n">plv_combined_ground_truth_matrices</span><span class="p">[</span>
                                    <span class="n">idx_freq</span>
                                <span class="p">][</span><span class="n">idx_row</span><span class="p">][</span><span class="n">idx_col</span><span class="p">]</span>
                                <span class="c1"># Get pair label of electorode</span>
                                <span class="n">sig_electrode_pair_label</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">get_electrode_labels_connections</span><span class="p">(</span><span class="n">idx_sig_connection</span><span class="p">)</span>
                                <span class="p">)</span>

                                <span class="n">electrode_pair_n_actual_score_plv</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="n">sig_electrode_pair_label</span><span class="p">:</span> <span class="n">actual_score</span>
                                <span class="p">}</span>

                                <span class="c1"># Put that string into a unique list (theta, alpha, beta, or gamma list for plv)</span>
                                <span class="k">if</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">theta_sig_electrode_pair_plv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_plv</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">alpha_sig_electrode_pair_plv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_plv</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                    <span class="n">beta_sig_electrode_pair_plv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_plv</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                    <span class="n">gamma_sig_electrode_pair_plv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_plv</span>
                                    <span class="p">)</span>

                <span class="c1"># Create main list that contains all the above 4 lists of frequency.</span>
                <span class="n">plv_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">theta_sig_electrode_pair_plv</span>
                <span class="p">)</span>
                <span class="n">plv_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">alpha_sig_electrode_pair_plv</span>
                <span class="p">)</span>
                <span class="n">plv_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">beta_sig_electrode_pair_plv</span>
                <span class="p">)</span>
                <span class="n">plv_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">gamma_sig_electrode_pair_plv</span>
                <span class="p">)</span>

                <span class="c1"># Progress getting actual score from marker significant connection matrix (coh)</span>
                <span class="c1"># Iterate over frequency (there are 4 , ie. theta, alpha, beta, gamma)</span>
                <span class="n">theta_sig_electrode_pair_coh</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">alpha_sig_electrode_pair_coh</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">beta_sig_electrode_pair_coh</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">gamma_sig_electrode_pair_coh</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">idx_freq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coh_combined_freq_n_connections</span><span class="p">)):</span>
                    <span class="c1"># Iterate over row of matrix (16 x 16)</span>
                    <span class="k">for</span> <span class="n">idx_row</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="n">coh_combined_freq_n_connections</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="c1"># Iterate over column of matrix (16 x 16)</span>
                        <span class="k">for</span> <span class="n">idx_col</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                            <span class="n">coh_combined_freq_n_connections</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">][</span><span class="n">idx_row</span><span class="p">]</span>
                        <span class="p">):</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="n">coh_combined_freq_n_connections</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">][</span><span class="n">idx_row</span><span class="p">][</span>
                                    <span class="n">idx_col</span>
                                <span class="p">]</span>
                                <span class="o">==</span> <span class="mi">1</span>
                            <span class="p">):</span>
                                <span class="n">idx_sig_connection</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">idx_row</span><span class="p">,</span> <span class="n">idx_col</span><span class="p">])</span>
                                <span class="c1"># Get actual score</span>
                                <span class="n">actual_score</span> <span class="o">=</span> <span class="n">coh_combined_ground_truth_matrices</span><span class="p">[</span>
                                    <span class="n">idx_freq</span>
                                <span class="p">][</span><span class="n">idx_row</span><span class="p">][</span><span class="n">idx_col</span><span class="p">]</span>
                                <span class="c1"># Get pair label of electorode</span>
                                <span class="n">sig_electrode_pair_label</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">get_electrode_labels_connections</span><span class="p">(</span><span class="n">idx_sig_connection</span><span class="p">)</span>
                                <span class="p">)</span>

                                <span class="n">electrode_pair_n_actual_score_coh</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="n">sig_electrode_pair_label</span><span class="p">:</span> <span class="n">actual_score</span>
                                <span class="p">}</span>

                                <span class="c1"># Put that string into a unique list (theta, alpha, beta, or gamma list for coh)</span>
                                <span class="k">if</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">theta_sig_electrode_pair_coh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_coh</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">alpha_sig_electrode_pair_coh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_coh</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                    <span class="n">beta_sig_electrode_pair_coh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_coh</span>
                                    <span class="p">)</span>
                                <span class="k">elif</span> <span class="n">idx_freq</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                                    <span class="n">gamma_sig_electrode_pair_coh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="n">electrode_pair_n_actual_score_coh</span>
                                    <span class="p">)</span>

                <span class="c1"># Create main list that contains all the above 4 lists of frequency.</span>
                <span class="n">coh_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">theta_sig_electrode_pair_coh</span>
                <span class="p">)</span>
                <span class="n">coh_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">alpha_sig_electrode_pair_coh</span>
                <span class="p">)</span>
                <span class="n">coh_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">beta_sig_electrode_pair_coh</span>
                <span class="p">)</span>
                <span class="n">coh_combined_freqs_electrode_pair_n_actual_score</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">gamma_sig_electrode_pair_coh</span>
                <span class="p">)</span>

                <span class="c1"># So there will be 3 main containers (actual score of ccor, plv, coh). Each of them has 4 lists (theta, alpha, beta, and gamma)</span>

                <span class="c1"># save ccorr connection data for a pair</span>
                <span class="n">saved_filename1</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">saved_directory</span>
                    <span class="o">+</span> <span class="s2">&quot;Pre_ccorr_combined_pair_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_and_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_connection_data.pkl&quot;</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">saved_filename1</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span>
                        <span class="n">ccorr_combined_freq_n_connections_list</span><span class="p">,</span>
                        <span class="n">handle</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># Save actual significant scores of ccorr for a pair</span>
                <span class="n">saved_actual_score_filename1</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">saved_directory</span>
                    <span class="o">+</span> <span class="s2">&quot;Pre_ccorr_combined_pair_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_and_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_actual_score_data.pkl&quot;</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">saved_actual_score_filename1</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span>
                        <span class="n">ccorr_combined_freqs_electrode_pair_n_actual_score</span><span class="p">,</span>
                        <span class="n">handle</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># save plv connection data for a pair</span>
                <span class="n">saved_filename2</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">saved_directory</span>
                    <span class="o">+</span> <span class="s2">&quot;Pre_plv_combined_pair_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_and_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_connection_data.pkl&quot;</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">saved_filename2</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span>
                        <span class="n">plv_combined_freq_n_connections_list</span><span class="p">,</span>
                        <span class="n">handle</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># Save actual significant scores of plv for a pair</span>
                <span class="n">saved_actual_score_filename2</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">saved_directory</span>
                    <span class="o">+</span> <span class="s2">&quot;Pre_plv_combined_pair_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_and_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_actual_score_data.pkl&quot;</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">saved_actual_score_filename2</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span>
                        <span class="n">plv_combined_freqs_electrode_pair_n_actual_score</span><span class="p">,</span>
                        <span class="n">handle</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># save coh connection data for a pair</span>
                <span class="n">saved_filename3</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">saved_directory</span>
                    <span class="o">+</span> <span class="s2">&quot;Pre_coh_combined_pair_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_and_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_connection_data.pkl&quot;</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">saved_filename3</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span>
                        <span class="n">coh_combined_freq_n_connections_list</span><span class="p">,</span>
                        <span class="n">handle</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># Save actual significant scores of coh for a pair</span>
                <span class="n">saved_actual_score_filename3</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">saved_directory</span>
                    <span class="o">+</span> <span class="s2">&quot;Pre_coh_combined_pair_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_and_S&quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;_actual_score_data.pkl&quot;</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">saved_actual_score_filename3</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span>
                        <span class="n">coh_combined_freqs_electrode_pair_n_actual_score</span><span class="p">,</span>
                        <span class="n">handle</span><span class="p">,</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">,</span>
                    <span class="p">)</span></div>

<div class="viewcode-block" id="Connections.count_sig_connections"><a class="viewcode-back" href="../../EEG.html#EEG.stats.Connections.count_sig_connections">[docs]</a>    <span class="k">def</span> <span class="nf">count_sig_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective : Count a number of significant connections for a certain eye condition, eg. averted_pre.</span>
<span class="sd">                    Divided into different algorithms (ccorr, coh, and plv) and frequencies (theta, alpha, beta, and gamma)</span>

<span class="sd">        Parameters :</span>
<span class="sd">                      path (str) : A path that contains *pkl file which contains actual scores of connections.</span>
<span class="sd">                                   Each *.pkl file will have a lenght of 4 (the order is theta, alpha, beta, and gamma)</span>

<span class="sd">        Outputs:</span>
<span class="sd">                    all_connections (namedtuple): it returns multiple values. The order is described below:</span>

<span class="sd">                    total_sig_ccorr_theta_connections, total_sig_ccorr_alpha_connections, total_sig_ccorr_beta_connections, total_sig_ccorr_gamma_connections,</span>
<span class="sd">                    total_sig_coh_theta_connections, total_sig_coh_alpha_connections, total_sig_coh_beta_connections, total_sig_coh_gamma_connections,</span>
<span class="sd">                    total_sig_plv_theta_connections, total_sig_plv_alpha_connections, total_sig_plv_beta_connections, total_sig_plv_gamma_connections,</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
            <span class="s2">&quot;results&quot;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="s2">&quot;total_sig_ccorr_theta_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_ccorr_alpha_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_ccorr_beta_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_ccorr_gamma_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_coh_theta_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_coh_alpha_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_coh_beta_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_coh_gamma_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_plv_theta_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_plv_alpha_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_plv_beta_connections&quot;</span><span class="p">,</span>
                <span class="s2">&quot;total_sig_plv_gamma_connections&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>

        <span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="c1"># Create new list to count the number of significant connection (eg. list_at, list_aa, list_ab, list_ag)</span>
        <span class="n">ccorr_sig_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coh_sig_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">plv_sig_connections</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Separate files into different container according to algorithm</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="c1"># ccorr</span>
            <span class="k">if</span> <span class="s2">&quot;actual_score_data&quot;</span> <span class="ow">in</span> <span class="n">file</span> <span class="ow">and</span> <span class="s2">&quot;ccorr&quot;</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">ccorr_sig_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
                <span class="c1"># Sort the list</span>
                <span class="n">ccorr_sig_connections</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="c1"># coh</span>
            <span class="k">elif</span> <span class="s2">&quot;actual_score_data&quot;</span> <span class="ow">in</span> <span class="n">file</span> <span class="ow">and</span> <span class="s2">&quot;coh&quot;</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">coh_sig_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
                <span class="c1"># Sort the list</span>
                <span class="n">coh_sig_connections</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="c1"># plv</span>
            <span class="k">elif</span> <span class="s2">&quot;actual_score_data&quot;</span> <span class="ow">in</span> <span class="n">file</span> <span class="ow">and</span> <span class="s2">&quot;plv&quot;</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">plv_sig_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
                <span class="c1"># Sort the list</span>
                <span class="n">plv_sig_connections</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Define list for ccorr per frequency</span>
        <span class="n">total_sig_ccorr_theta_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_sig_ccorr_alpha_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_sig_ccorr_beta_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_sig_ccorr_gamma_connections</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Define list for coh per frequency</span>
        <span class="n">total_sig_coh_theta_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_sig_coh_alpha_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_sig_coh_beta_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_sig_coh_gamma_connections</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Define list for plv per frequency</span>
        <span class="n">total_sig_plv_theta_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_sig_plv_alpha_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_sig_plv_beta_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_sig_plv_gamma_connections</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Count significant connection for ccorr algorithm and separate into 4 frequencies:</span>
        <span class="c1"># theta, alpha, beta, and gamma</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">ccorr_sig_connections</span><span class="p">:</span>
            <span class="n">ccorr_file_2_read</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="n">ccorr_file</span> <span class="o">=</span> <span class="n">read_pickle</span><span class="p">(</span><span class="n">ccorr_file_2_read</span><span class="p">)</span>

            <span class="c1"># Theta = 0th index in the list</span>
            <span class="n">sig_ccorr_theta_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccorr_file</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">total_sig_ccorr_theta_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_ccorr_theta_connections</span><span class="p">)</span>

            <span class="c1"># Alpha = 1st index in the list</span>
            <span class="n">sig_ccorr_alpha_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccorr_file</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">total_sig_ccorr_alpha_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_ccorr_alpha_connections</span><span class="p">)</span>

            <span class="c1"># Beta = 2nd index in the list</span>
            <span class="n">sig_ccorr_beta_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccorr_file</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">total_sig_ccorr_beta_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_ccorr_beta_connections</span><span class="p">)</span>

            <span class="c1"># Gamma = 3rd index in the list</span>
            <span class="n">sig_ccorr_gamma_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccorr_file</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">total_sig_ccorr_gamma_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_ccorr_gamma_connections</span><span class="p">)</span>

        <span class="c1"># Count significant connection for coh algorithm and separate into 4 frequencies:</span>
        <span class="c1"># theta, alpha, beta, and gamma</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">coh_sig_connections</span><span class="p">:</span>
            <span class="n">coh_file_2_read</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="n">coh_file</span> <span class="o">=</span> <span class="n">read_pickle</span><span class="p">(</span><span class="n">coh_file_2_read</span><span class="p">)</span>

            <span class="c1"># Theta = 0th index in the list</span>
            <span class="n">sig_coh_theta_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_file</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">total_sig_coh_theta_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_coh_theta_connections</span><span class="p">)</span>

            <span class="c1"># Alpha = 1st index in the list</span>
            <span class="n">sig_coh_alpha_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_file</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">total_sig_coh_alpha_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_coh_alpha_connections</span><span class="p">)</span>

            <span class="c1"># Beta = 2nd index in the list</span>
            <span class="n">sig_coh_beta_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_file</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">total_sig_coh_beta_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_coh_beta_connections</span><span class="p">)</span>

            <span class="c1"># Gamma = 3rd index in the list</span>
            <span class="n">sig_coh_gamma_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coh_file</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">total_sig_coh_gamma_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_coh_gamma_connections</span><span class="p">)</span>

        <span class="c1"># Count significant connection for plv algorithm and separate into 4 frequencies:</span>
        <span class="c1"># theta, alpha, beta, and gamma</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">plv_sig_connections</span><span class="p">:</span>
            <span class="n">plv_file_2_read</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="n">plv_file</span> <span class="o">=</span> <span class="n">read_pickle</span><span class="p">(</span><span class="n">plv_file_2_read</span><span class="p">)</span>

            <span class="c1"># Theta = 0th index in the list</span>
            <span class="n">sig_plv_theta_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plv_file</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">total_sig_plv_theta_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_plv_theta_connections</span><span class="p">)</span>

            <span class="c1"># Alpha = 1st index in the list</span>
            <span class="n">sig_plv_alpha_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plv_file</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">total_sig_plv_alpha_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_plv_alpha_connections</span><span class="p">)</span>

            <span class="c1"># Beta = 2nd index in the list</span>
            <span class="n">sig_plv_beta_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plv_file</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">total_sig_plv_beta_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_plv_beta_connections</span><span class="p">)</span>

            <span class="c1"># Gamma = 3rd index in the list</span>
            <span class="n">sig_plv_gamma_connections</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plv_file</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">total_sig_plv_gamma_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig_plv_gamma_connections</span><span class="p">)</span>

        <span class="n">all_connections</span> <span class="o">=</span> <span class="n">results</span><span class="p">(</span>
            <span class="n">total_sig_ccorr_theta_connections</span><span class="p">,</span>
            <span class="n">total_sig_ccorr_alpha_connections</span><span class="p">,</span>
            <span class="n">total_sig_ccorr_beta_connections</span><span class="p">,</span>
            <span class="n">total_sig_ccorr_gamma_connections</span><span class="p">,</span>
            <span class="n">total_sig_coh_theta_connections</span><span class="p">,</span>
            <span class="n">total_sig_coh_alpha_connections</span><span class="p">,</span>
            <span class="n">total_sig_coh_beta_connections</span><span class="p">,</span>
            <span class="n">total_sig_coh_gamma_connections</span><span class="p">,</span>
            <span class="n">total_sig_plv_theta_connections</span><span class="p">,</span>
            <span class="n">total_sig_plv_alpha_connections</span><span class="p">,</span>
            <span class="n">total_sig_plv_beta_connections</span><span class="p">,</span>
            <span class="n">total_sig_plv_gamma_connections</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">all_connections</span></div>

<div class="viewcode-block" id="Connections.diff_n_connections_pre_post"><a class="viewcode-back" href="../../EEG.html#EEG.stats.Connections.diff_n_connections_pre_post">[docs]</a>    <span class="k">def</span> <span class="nf">diff_n_connections_pre_post</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">averted_pre</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">averted_post</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">direct_pre</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">direct_post</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">natural_pre</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">natural_post</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective  : To find difference (absolute number) between pre and post for each eye condition, combination algorithm and frequency</span>

<span class="sd">        Parameters :</span>

<span class="sd">                     These are the results of count_sig_connections function. Run it for each eye condition</span>
<span class="sd">                     each result will become an input of this function.</span>

<span class="sd">        Outputs    :</span>
<span class="sd">                     - diff_averted</span>
<span class="sd">                     - diff_direct</span>
<span class="sd">                     - diff_natural</span>

<span class="sd">                    NOTE : Read the notes below to understand the structure of the above output of three variables</span>

<span class="sd">                    These are the order of list for each eye condition (diff_averted, diff_direct, diff_natural)</span>
<span class="sd">                    total_sig_ccorr_theta_connections, total_sig_ccorr_alpha_connections, total_sig_ccorr_beta_connections, total_sig_ccorr_gamma_connections,</span>
<span class="sd">                    total_sig_coh_theta_connections, total_sig_coh_alpha_connections, total_sig_coh_beta_connections, total_sig_coh_gamma_connections,</span>
<span class="sd">                    total_sig_plv_theta_connections, total_sig_plv_alpha_connections, total_sig_plv_beta_connections, total_sig_plv_gamma_connections</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">diff_averted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">diff_direct</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">diff_natural</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">averted_pre</span><span class="p">)</span>
        <span class="p">):</span>  <span class="c1"># NOTE : The length is 12 means there are 12 outputs</span>
            <span class="c1"># that are resulted from the count_sig_connections function</span>
            <span class="c1"># Just pick up averted_pre variable</span>
            <span class="n">diff_averted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">averted_post</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">averted_pre</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
            <span class="p">)</span>

            <span class="n">diff_direct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">direct_post</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">direct_pre</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
            <span class="p">)</span>

            <span class="n">diff_natural</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">natural_post</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">natural_pre</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">diff_averted</span><span class="p">,</span> <span class="n">diff_direct</span><span class="p">,</span> <span class="n">diff_natural</span></div>

<div class="viewcode-block" id="Connections.corr_eeg_connection_n_question"><a class="viewcode-back" href="../../EEG.html#EEG.stats.Connections.corr_eeg_connection_n_question">[docs]</a>    <span class="k">def</span> <span class="nf">corr_eeg_connection_n_question</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">diff_connection</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">list</span><span class="p">],</span> <span class="n">diff_scale</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective  : Analyze pearson correlation between number of connections of EEG</span>
<span class="sd">                    (substracted between post and pre) and subscale of SPGQ or SPGQ total score</span>

<span class="sd">        Parameters :</span>
<span class="sd">                    - diff_connection(List[list]) : Substracted number of connections of EEG. Each list will have six order</span>
<span class="sd">                                                    as follow :  Resulted from EEG.Analysis.diff_n_connections_pre_post funct</span>

<span class="sd">                                                diff_connect_ccorr_theta_connections, diff_connect_ccorr_alpha_connections, diff_connect_ccorr_beta_connections, diff_connect_ccorr_gamma_connections,</span>
<span class="sd">                                                diff_connect_coh_theta_connections, diff_connect_coh_alpha_connections, diff_connect_coh_beta_connections, diff_connect_coh_gamma_connections,</span>
<span class="sd">                                                diff_connect_plv_theta_connections, diff_connect_plv_alpha_connections, diff_connect_plv_beta_connections, diff_connect_plv_gamma_connections</span>


<span class="sd">                    - diff_scale(list) :  Substracted subscale / total score of SPGQ between pre and post</span>

<span class="sd">                                            - &quot;Empathy SPGQ&quot;</span>
<span class="sd">                                            - &quot;NegativeFeelings SPGQ&quot;</span>
<span class="sd">                                            - &quot;Behavioural SPGQ&quot;</span>
<span class="sd">                                            - &quot;SPGQ Total&quot;</span>
<span class="sd">                                            - &quot;CoPresence Total&quot;</span>
<span class="sd">                                            Resulted from Questionnnaire.questionnaire.diff_score_questionnaire_pre_post funct</span>

<span class="sd">                    - title (str)      : Title of correlation between which eye condition and subscale of questionnaire</span>

<span class="sd">        Output     :</span>
<span class="sd">                     Print Correlational score between the following connections and subscale of questionnaire (SPGQ)</span>

<span class="sd">                     diff_connect_ccorr_theta_connections, diff_connect_ccorr_alpha_connections, diff_connect_ccorr_beta_connections, diff_connect_ccorr_gamma_connections,</span>
<span class="sd">                     diff_connect_coh_theta_connections, diff_connect_coh_alpha_connections, diff_connect_coh_beta_connections, diff_connect_coh_gamma_connections,</span>
<span class="sd">                     diff_connect_plv_theta_connections, diff_connect_plv_alpha_connections, diff_connect_plv_beta_connections, diff_connect_plv_gamma_connections</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diff_connection</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">diff_connection</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">diff_scale</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Connections.corr_eeg_connection_n_eye"><a class="viewcode-back" href="../../EEG.html#EEG.stats.Connections.corr_eeg_connection_n_eye">[docs]</a>    <span class="k">def</span> <span class="nf">corr_eeg_connection_n_eye</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">diff_eye_cond</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">diff_eeg_connections</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective : Find correlation between eye gaze percentage of looking and a number of eeg connections</span>

<span class="sd">        Parameters:</span>
<span class="sd">                    - diff_eye_cond (list)              : Percentage of looking that has been deducted between pre and post</span>
<span class="sd">                    - diff_eeg_connections (List[list]) : Number of connections of EEG that has been deducted between pre and post.</span>
<span class="sd">                                                          It is the output of diff_n_connections_pre_pos function</span>

<span class="sd">        Output    :</span>
<span class="sd">                    corr_eye_eeg(list): Pearson correlational values. This is the order :</span>

<span class="sd">                                        total_sig_ccorr_theta_connections, total_sig_ccorr_alpha_connections, total_sig_ccorr_beta_connections, total_sig_ccorr_gamma_connections,</span>
<span class="sd">                                        total_sig_coh_theta_connections, total_sig_coh_alpha_connections, total_sig_coh_beta_connections, total_sig_coh_gamma_connections,</span>
<span class="sd">                                        total_sig_plv_theta_connections, total_sig_plv_alpha_connections, total_sig_plv_beta_connections, total_sig_plv_gamma_connections</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corr_eye_eeg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diff_eeg_connections</span><span class="p">):</span>
            <span class="n">corr_eye_eeg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">diff_eye_cond</span><span class="p">,</span> <span class="n">diff_eeg_connections</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">corr_eye_eeg</span></div>

<div class="viewcode-block" id="Connections.plot_eeg_connection_n_question"><a class="viewcode-back" href="../../EEG.html#EEG.stats.Connections.plot_eeg_connection_n_question">[docs]</a>    <span class="k">def</span> <span class="nf">plot_eeg_connection_n_question</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x_axis_diff_connection</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">y_axis_diff_scale</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">xlabel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective : Plot a correlation (scatter plot) between number of connections (EEG) and</span>
<span class="sd">                    score of subscale of SPGQ / Co-Presence</span>

<span class="sd">        Parameters :</span>
<span class="sd">                    - x_axis_diff_connection (list) : (data for x axis) Number of connections for a certain eye conditon, algorithm, and frequency</span>
<span class="sd">                    - y_axis_diff_scale (list)      : (data for y axis) Score of subscale for a certain eye conditon</span>
<span class="sd">                                                        - &quot;Empathy SPGQ&quot;</span>
<span class="sd">                                                        - &quot;NegativeFeelings SPGQ&quot;</span>
<span class="sd">                                                        - &quot;Behavioural SPGQ&quot;</span>
<span class="sd">                                                        - &quot;SPGQ Total&quot;</span>
<span class="sd">                                                        - &quot;CoPresence Total&quot;</span>
<span class="sd">                                                        Take ONE of the lists that is resulted from EEG.Analysis.diff_n_connections_pre_post funct</span>
<span class="sd">                                                        as an input</span>

<span class="sd">                    - title (str)                   : Title for the plot</span>
<span class="sd">                    - xlabel (str)                  : Xlabel for the plot</span>
<span class="sd">                    - ylabel (str)                  : Ylabel for the plot</span>

<span class="sd">        Output     :</span>
<span class="sd">                      Plot</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># adds the title</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="c1"># plot the data</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_axis_diff_connection</span><span class="p">,</span> <span class="n">y_axis_diff_scale</span><span class="p">)</span>

        <span class="c1"># fits the best fitting line to the data</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x_axis_diff_connection</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x_axis_diff_connection</span><span class="p">,</span> <span class="n">y_axis_diff_scale</span><span class="p">,</span> <span class="mi">1</span><span class="p">))(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x_axis_diff_connection</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Labelling axes</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Ihshan Gumilar.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>